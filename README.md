# nodejs-shpargalka
shpargalka - node.js  https://www.codementor.io/mattgoldspink/nodejs-best-practices-du1086jja
1.Запуск всех проектов с помощью npm init 
Большинство людей знакомы с NPM как способ установки зависимостей, но это намного больше, чем это. Во-первых, я настоятельно рекомендую создать новый проект, используя npm init, например

    $ mkdir my-new-project
    $ cd my-new-project
    $ npm init
    
Это создаст новый пакет.json для вас, который позволит вам добавить кучу метаданных, чтобы помочь другим, работающим над проектом, иметь ту же настройку, что и вы

Например, я обычно открываю package.json и добавляю определенную версию Node.js, над которой я планирую работать, добавив:

    "engines": {
      "node": "6.2.0"
    }

2. Настройка .npmrc 

Если вы использовали npm раньше, вы можете встретить флаг -save, который обновляет package.json с зависимостью. Из-за этого, когда другие разработчики клонируют проект, они могут быть уверены в правильности зависимостей. К сожалению, помнить о добавлении флага может быть проблемой.

Кроме того, NPM добавляет ведущую каретку ^ во все версии. Следовательно, когда кто-то запускает установку npm, они могут получать разные версии модулей, чем то, что у вас есть.

Несмотря на то, что обновление модулей modules всегда является хорошей практикой, команда разработчиков, работающая с несколькими разными версиями зависимостей, может привести к различиям в поведении или доступности API. Поэтому рекомендуется иметь всех в одной версии. Чтобы сделать это проще для всех, файл .npmrc имеет некоторые полезные свойства, которые могут гарантировать, что npm install всегда обновляет package.json и обеспечивает соответствие версии установленной зависимости точно.

Просто запустите следующие строки в терминале:

    $ npm config set save=true
    $ npm config set save-exact=true
    
Теперь, когда вы запускаете npm install, вы можете быть уверены, что зависимость сохранена и будет заблокирована до установленной вами версии.

3. Добавьте скрипты в свой пакет package.json

Если есть что-то, что нужно всем приложениям, это сценарий запуска.Зная, какой файл вызывать первым и какие аргументы могут быть эпическим приключением открытия в некоторых проектах.Хорошо, что NPM имеет стандартный способ запуска всех node приложений.
Просто добавьте свойство scripts и объект к вашему package.json с ключом запуска. Это значение должно быть командой для запуска вашего приложения. Например:

    "scripts": {
      "start": "node myapp.js"
    }
    
 Как только кто-то запускает npm start, NPM запустит node myapp.js со всеми зависимостями от node_modules / .bin на вашей $ PATH.
 Это означает, что вы можете избежать необходимости выполнять глобальные установки модулей NPM.
 
 Есть пара других скриптов, которые стоит знать:
 
 
     "scripts": {
      "postinstall": "bower install && grunt build",
      "start": "node myapp.js",
      "test": "node ./node_modules/jasmine/bin/jasmine.js"
    }
    
Сценарий postinstall запускается после запуска установки npm. Также есть preinstall, если вам нужно что-то запустить, прежде чем будут установлены все зависимости NPM.

Сценарий тестирования запускается, когда кто-то запускает проверку на npm. Это хороший простой способ, чтобы кто-то мог выполнять ваши тесты, не выясняя, выбрали ли вы использовать Jasmine, Mocha, Selenium и т. Д. Здесь вы можете добавить свои собственные скрипты. Затем их можно запустить с помощью npm run-script {name} - простой способ предоставить вашей команде центральный набор сценариев запуска.

4. Используйте переменные среды 
Управление конфигурацией всегда является большой темой на любом языке.
Как вы отделяете свой код от баз данных, сервисов и т. Д., Которые он должен использовать во время разработки, контроля качества и производства?

Рекомендуемым способом в Node.js является использование переменных среды и поиск значений из process.env в вашем коде.Например, чтобы выяснить, в какой среде вы работаете, проверьте переменные среды NODE_ENV:

    console.log("Running in :"  + process.env.NODE_ENV);
Теперь это стандартное имя переменной, используемое большинством поставщиков облачных хостингов.    
Если вам нужно загрузить дополнительные конфигурации, вы можете использовать модуль, например https://github.com/indexzero/nconf
Другой популярный вариант загрузки переменных среды https://github.com/motdotla/dotenv (Thanks to @szabi)

5. Используйте руководство по стилю

Я знаю, что у всех нас были моменты, когда мы впервые открываем новый файл из другого проекта или файл поступает от другого разработчика,мы затем проводим следующий час, переформатируя фигурные скобки, чтобы быть на разных линиях, изменяя пробелы на вкладки и наоборот.Проблема здесь - это смесь упрямых разработчиков и руководство по стандартным стилям команды / компании.

Это также уменьшает когнитивные издержки, следует ли писать письма с помощью вкладок или пробелов.Если стиль продиктован (и применяется с использованием JSHint, ESlint или JSCS), то все внезапно, кодовая база становится намного более управляемой.
Вам также не нужно выходить со своими собственными правилами, иногда лучше выбирать существующий набор рекомендаций и следовать им. Вот несколько хороших примеров:

Airbnb - https://github.com/airbnb/javascript
Google - https://google.github.io/styleguide/javascriptguide.xml
jQuery - https://contribute.jquery.org/style-guide/js/
Standard JS - http://standardjs.com/ - thanks to @szabi for pointing out this one 
Просто выберите один и придерживайтесь его!

6. Объявите async
Я уверен, что вы слышали всю шумиху о promis, возможно, даже немного слышали об async / await и генераторах в ES2016. Основная идея всех этих методов - сделать ваш код асинхронным.

Проблема с синхронными функциями в JavaScript заключается в том, что они блокируют запуск любого другого кода до его завершения.Однако синхронный код упрощает понимание потока логики приложения.С другой стороны, асинхронные структуры, такие как promis, действительно возвращают много таких рассуждений, сохраняя при этом ваш код без блокировок. 


Во-первых, я настоятельно рекомендую запустить приложение (только при разработке) с флагом 

    -trace-sync-io.

Это приведет к печати предупреждений и трассировки стека всякий раз, когда ваше приложение использует синхронный API.

Существует множество замечательных статей о том, как использовать promises, generators and async / await. Мне не нужно дублировать другую замечательную работу, которая уже доступна, поэтому вот несколько ссылок, которые помогут вам начать:

Promises - http://www.html5rocks.com/en/tutorials/es6/promises/
Async / Await - https://www.twilio.com/blog/2015/10/asyncawait-the-hero-javascript-deserved.html
Generators - https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Iterators_and_Generators

7. Обработать ошибки

Ошибка при сбое всего вашего приложения в производстве никогда не является отличным опытом.Хорошее управление исключениями важно для любого приложения, и лучший способ справиться с ошибками - использовать асинхронные структуры выше.
Например, обещания предоставляют обработчик .catch (), который будет распространять все ошибки, с которыми нужно обращаться, чисто.

Допустим, у вас есть цепочка promis, и любой из них может неожиданно провалиться, вы можете легко справиться с ошибкой:

    doSomething()
        .then(doNextStage)
        .then(recordTheWorkSoFar)
        .then(updateAnyInterestedParties)
        .then(tidyUp)
        .catch(errorHandler);
        
В приведенном выше примере не имеет значения, какая из ранних функций могла быть неудачной, любая ошибка закончится в errorHandler.

8. Убедитесь, что приложение автоматически перезапускается
Хорошо, поэтому вы следовали лучшей практике для обработки ошибок. К сожалению, некоторая ошибка из-за зависимости все-таки сбила ваше приложение 

Здесь важно убедиться, что вы используете диспетчер процессов, чтобы убедиться, что приложение изящно восстанавливается из-за ошибки времени выполнения (runtime error). Другой сценарий, в котором вы нуждаетесь, чтобы перезапустить, - это если весь сервер, на котором вы работаете, спустился. В этой ситуации вам нужно минимальное время простоя и для запуска приложения, как только сервер снова будет жив!
Я бы рекомендовал использовать PM2 KeyMetric http://pm2.keymetrics.io/ для управления процессом.  Хотя другие варианты включают (Nodemon)[http://nodemon.io/] (thanks @szabi) and (Forever)[https://github.com/foreverjs/forever].

Сначала установите его как глобальный модуль:

    $ npm install pm2 -g
    
Затем, чтобы запустить ваш процесс, вы должны запустить:

    $ pm2 start myApp.js
    
Чтобы обработать перезапуск после сбоя сервера, вы можете следовать руководству PM2 для вашей платформы:

http://pm2.keymetrics.io/docs/usage/startup/


9. Кластерное приложение для повышения производительности и надежности
По умолчанию Node.js запускается в одном процессе. В идеале вам нужен один процесс для каждого ядра ЦП, чтобы вы могли распределять рабочую нагрузку по всем ядрам. 




 
 
 
 
 
 
 
 
 
 
 
 
